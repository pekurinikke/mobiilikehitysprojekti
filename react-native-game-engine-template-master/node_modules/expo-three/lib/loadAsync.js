// @flow
import Expo from 'expo';
import resolveAsset, { stringFromAsset } from './resolveAsset';
import THREE from './Three';

// Asset loading logic
export default (loadAsync = async (res, onProgress, assetProvider) => {
  const urls = await resolveAsset(res);
  if (!urls) {
    console.error(
      `ExpoTHREE.loadAsync: Cannot parse undefined assets. Please pass valid resources for: ${res}.`
    );
    return;
  }

  const asset = urls[0];
  const url = await stringFromAsset(asset);

  if (urls.length === 1) {
    return loadSingleAsset(url, asset, onProgress, assetProvider);
  } else if (urls.length === 2) {
    return loadMultiAsset(urls, onProgress, assetProvider);
  } else {
    console.error('Too many arguments passed', urls);
    return;
  }
});

// Handle the loading of a single asset based on its file extension
const loadSingleAsset = async (url, asset, onProgress, assetProvider) => {
  if (url.match(/\.(jpeg|jpg|gif|png)$/)) {
    return parseTexture(asset);
  } else if (url.match(/\.stl$/i)) {
    return loadModel(url, 'STLLoader', onProgress);
  } else if (url.match(/\.pcd$/i)) {
    return loadModel(url, 'PCDLoader', onProgress);
  } else if (url.match(/\.(vtk|vtp)$/i)) {
    return loadModel(url, 'VTKLoader', onProgress);
  } else if (url.match(/\.babylon$/i)) {
    return loadModel(url, 'BabylonLoader', onProgress);
  } else if (url.match(/\.assimp$/i)) {
    return loadModel(url, 'AssimpLoader', onProgress, true);
  } else if (url.match(/\.amf$/i)) {
    return loadModel(url, 'AMFLoader', onProgress);
  } else if (url.match(/\.3ds$/i)) {
    return loadModel(url, 'TDSLoader', onProgress, assetProvider);
  } else if (url.match(/\.bvh$/i)) {
    return loadModel(url, 'BVHLoader', onProgress, assetProvider);
  } else if (url.match(/\.ply$/i)) {
    return loadModel(url, 'PLYLoader', onProgress);
  } else if (url.match(/\.dae$/i)) {
    return loadColladaModel(url, onProgress, assetProvider);
  } else if (url.match(/\.x$/i)) {
    return loadModel(url, 'XLoader', onProgress, assetProvider);
  } else if (url.match(/\.json$/i)) {
    console.error('loadAsync: JSON should not be loaded as an Expo.Asset!');
    return;
  } else if (url.match(/\.obj$/i)) {
    return loadModel(url, 'OBJLoader', onProgress, assetProvider);
  } else if (url.match(/\.mtl$/i)) {
    return loadModel(url, 'MTLLoader', onProgress, assetProvider);
  } else {
    console.error('Unrecognized File Type', url);
  }
};

// Handle loading of multiple assets (e.g., OBJ + MTL)
const loadMultiAsset = async (urls, onProgress, assetProvider) => {
  const [urlA, urlB] = await Promise.all(urls.map(stringFromAsset));
  
  if (urlA.match(/\.mtl$/i) && urlB.match(/\.obj$/i)) {
    return loadOBJMTL(urlB, urlA, onProgress, assetProvider);
  } else if (urlA.match(/\.obj$/i) && urlB.match(/\.mtl$/i)) {
    return loadOBJMTL(urlA, urlB, onProgress, assetProvider);
  }
  
  console.error('Unrecognized File Type', urls);
};

// Load a model using the appropriate loader
const loadModel = (url, loaderName, onProgress, assetProvider = '') => {
  require(`three/examples/js/loaders/${loaderName}`);
  const loader = new THREE[loaderName]();
  loader.setPath(assetProvider);

  return new Promise((res, rej) =>
    loader.load(url, res, onProgress, rej)
  );
};

// Special handler for loading Collada models
const loadColladaModel = (url, onProgress, assetProvider) => {
  require('three/examples/js/loaders/ColladaLoader');
  
  return new Promise((res, rej) =>
    new THREE.FileLoader().load(
      url,
      text => {
        const loader = new THREE.ColladaLoader();
        res(loader.parse(text, assetProvider));
      },
      onProgress,
      rej
    )
  );
};

// Load OBJ and MTL together
const loadOBJMTL = async (objLocalUri, mtlLocalUri, onProgress, assetProvider) => {
  const materials = await loadAsync(mtlLocalUri, onProgress, assetProvider);
  materials.preload();
  
  return loadModel(objLocalUri, 'OBJLoader', onProgress, assetProvider)
    .then(model => {
      const loader = new THREE.OBJLoader();
      loader.setPath(assetProvider);
      loader.setMaterials(materials);
      return loader.parse(model);
    });
};

// Load texture for a model
const loadTexture = function(url, onLoad, onProgress, onError) {
  const texture = new THREE.Texture();
  if (typeof this.path === 'function') {
    (async () => {
      url = url.split('/').pop();
      const asset = await this.path(url);
      const { minFilter, image } = await loadAsync(asset);
      texture.image = image;
      texture.needsUpdate = true;
      texture.isDataTexture = true;
      texture.minFilter = minFilter;

      if (onLoad) {
        onLoad(texture);
      }
    })();
  }
  return texture;
};

// Override TextureLoader to use the `path` component
THREE.TextureLoader.prototype.load = loadTexture;

// Parse texture from raw asset data
const parseTexture = (asset) => {
  const texture = new THREE.Texture();
  texture.image = {
    data: asset,
    width: asset.width,
    height: asset.height,
  };
  texture.needsUpdate = true;
  texture.isDataTexture = true;
  texture.minFilter = THREE.LinearFilter;
  return texture;
};

const loadRawFileAsync = async (localUri: string): string => {
  console.time('loadAsset');
  console.log('Load local file', localUri);

  let file;
  try {
    file = await Expo.FileSystem.readAsStringAsync(localUri);
  } catch (error) {
    console.error('Error loading raw file', error);
  } finally {
    console.timeEnd('loadAsset');
    return file || '';
  }
};
